#include <Gamebuino-Meta.h>
#include "Global.h"


// Life + (11)
const uint16_t bonusVieData[] = {7,5,3, 5, 0xf80d, 0, 0xf80d,0x4800,0x4800,0x8410,0x4800,0x4800,0xf80d,0xc340,0x7800,0xf800,0x7800,0xf800,0x7800,0xe420,0xbb82,0x7800,0xf800,0xf800,0xf800,0x7800,0xcb60,0xf80d,0xd480,0x7800,0xf800,0x7800,0xdbe0,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xd400,0xdbe0,0xe420,0xe4a0,0xdd01,0xf80d,0xbb60,0xe460,0xecc2,0xed23,0xdd62,0xdda2,0xe420,0xb383,0x4800,0xf800,0x8410,0xf800,0x4800,0xcb80,0xf84c,0xa000,0xa000,0x4800,0xa000,0xa000,0xf86c,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xd440,0xa000,0xa000,0xa000,0xe541,0xf80d,0xd3c1,0xdd62,0xe440,0xf800,0xe440,0xddc2,0xe440,0xc3c3,0xe440,0xe440,0xe4e2,0xe440,0xe440,0xcb80,0xf80d,0xe440,0xe440,0xe666,0xe440,0xe440,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d};
Image bonusVie = Image(bonusVieData);

// Paddle + (12)
const uint16_t bonusPaddlePlusData[] = {7,5,3, 5, 0xf80d, 0, 0xf80d,0xb7e0,0xdfef,0xdfef,0xb7e0,0x2580,0xf80d,0xb7e0,0x2580,0x2580,0xffff,0x2580,0x2580,0x2580,0x3260,0x5380,0xffff,0xffff,0xffff,0x5380,0x3260,0xf80d,0x3260,0x5380,0xffff,0x5380,0x3260,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xb7e0,0xdfef,0xdfef,0xb7e0,0x2580,0xf80d,0xb7e0,0x2580,0x2580,0x2580,0x2580,0x2580,0x2580,0x5380,0x5380,0x5380,0x5380,0x5380,0x5380,0x5380,0xf80d,0x3260,0x5380,0x5380,0x5380,0x3260,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xb7e0,0xffff,0xffff,0xffff,0x2580,0xf80d,0xb7e0,0x2580,0x2580,0xffff,0x2580,0x2580,0x2580,0x3260,0x5380,0x5380,0x5380,0x5380,0x5380,0x3260,0xf80d,0x3260,0x5380,0x5380,0x5380,0x3260,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d};
Image bonusPaddlePlus = Image(bonusPaddlePlusData);

// Paddle - (13)
const uint16_t bonusPaddleMalusData[] = {7,5,3, 5, 0xf80d, 0, 0xf80d,0xf800,0xfa8a,0xffff,0xfa8a,0xf800,0xf80d,0xf800,0xa8a0,0xfb40,0xfb40,0xfb40,0x8060,0xf800,0xa800,0xa800,0xa800,0xa800,0xa800,0xa800,0xa800,0xf80d,0xa800,0x7800,0x7800,0x7800,0xa800,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf800,0xfa8a,0xffff,0xfa8a,0xf800,0xf80d,0xf800,0xf800,0xf800,0xf800,0xf800,0xe100,0xf800,0xa800,0xa800,0x9080,0xa800,0x9080,0xa800,0xa800,0xf80d,0xa800,0xa200,0xa200,0xa200,0xa800,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf800,0xfa8a,0xffff,0xfa8a,0xf800,0xf80d,0xf800,0xf800,0xf800,0xf800,0xf800,0xe100,0xf800,0xa800,0xa800,0xa800,0xa800,0xa800,0xa800,0xa800,0xf80d,0xa800,0x7800,0x7800,0x7800,0xa800,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d};
Image bonusPaddleMalus = Image(bonusPaddleMalusData);

// Glue (14)
const uint16_t bonusGlueData[] = {7,5,3, 5, 0xf80d, 0, 0xf80d,0xb7e0,0x3186,0x3186,0xb7e0,0x7629,0xf80d,0x7629,0x6587,0x65e6,0x5e46,0x65e6,0x6d87,0x7629,0x4607,0x74a8,0x6d07,0x6527,0x6d07,0x74a8,0x4607,0xf80d,0x43c7,0x44c7,0x44c7,0x44c7,0x43c7,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0x4208,0x8410,0xb7f4,0xb7e0,0x7629,0xf80d,0x7629,0x3186,0x65e6,0x3186,0x3186,0x6d87,0x7629,0x4607,0x3186,0x6d07,0x6527,0x3186,0x74a8,0x4607,0xf80d,0x43c7,0x3186,0x3186,0x44c7,0x43c7,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xb7e0,0xb7f4,0xb7f4,0xb7e0,0x7629,0xf80d,0x7629,0x6587,0x65e6,0x5e46,0x65e6,0x6d87,0x7629,0x4607,0x74a8,0x0,0x0,0x0,0x74a8,0x4607,0xf80d,0x0,0x44c7,0x44c7,0x44c7,0x43c7,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d};
Image bonusGlue = Image(bonusGlueData);

// 15 & 16 not implemented atm (speed + or -)

// 17 Smallest Paddle
const uint16_t bonusMalusPaddleRedData[] = {7,5,3, 5, 0xf80d, 0, 0xf80d,0xfb2c,0x481f,0x481f,0x481f,0xf800,0xf80d,0xf800,0x481f,0xf800,0xf800,0xf800,0x481f,0xf800,0x481f,0xf800,0x481f,0x481f,0x481f,0xf800,0x481f,0xf80d,0x481f,0x500f,0x500f,0x500f,0x481f,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xfb2c,0xfd75,0xfd75,0xfb2c,0xf800,0xf80d,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0xb000,0xb000,0x13f,0x13f,0x13f,0xb000,0xb000,0xf80d,0x13f,0x7800,0x7800,0x7800,0x13f,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0x13f,0xfbef,0xfbef,0xfbef,0x13f,0xf80d,0xf800,0xf800,0x13f,0x13f,0x13f,0xf800,0xf800,0xb000,0xb000,0xb000,0xb000,0xb000,0xb000,0xb000,0xf80d,0x7800,0x7800,0x7800,0x7800,0x7800,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d};
Image bonusMalusPaddleRed = Image(bonusMalusPaddleRedData);

// Life - (18)
const uint16_t bonusMalusLifeData[] = {7,5,3, 5, 0xf80d, 0, 0xf80d,0x4208,0xd5f7,0xdefb,0xd5f7,0x4208,0xf80d,0xf800,0x4208,0x0,0xddf7,0x0,0x4208,0xf800,0x4800,0xf800,0xfefb,0x0,0xfefb,0xf800,0x4800,0xf80d,0x7800,0x4208,0xffff,0x4208,0x7800,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xd400,0xdbe0,0xe420,0xe4a0,0xdd01,0xf80d,0xf800,0xe460,0x4208,0x4208,0x4208,0xdda2,0xf800,0x4800,0x4208,0xdefb,0xef7d,0xdefb,0x4208,0x4800,0xf84c,0x4208,0x0,0xc618,0x0,0x4208,0xf86c,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0x4208,0x9cf3,0x0,0x9cf3,0x4208,0xf80d,0xf800,0xf800,0x9cf3,0xff7d,0x9cf3,0xf800,0xf800,0x4800,0xf800,0x4208,0x9cf3,0x4208,0xf800,0x4800,0xf80d,0x7800,0x7800,0xf800,0x7800,0x7800,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d};
Image bonusMalusLife = Image(bonusMalusLifeData);

// Ball - (19)
const uint16_t bonusMalusBallData[] = {7,5,3, 1, 0xf80d, 0, 0xf80d,0xffff,0xffff,0xfb40,0xfb8e,0xf800,0xf80d,0xfb8e,0xffff,0xfec0,0xfb40,0xf800,0xf800,0xf800,0x8800,0xfb40,0xffff,0xffff,0xffff,0xc000,0x8800,0xf80d,0x8800,0xc000,0xc000,0xc000,0x8800,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xfb8e,0xdfef,0xdfef,0xfb8e,0xf800,0xf80d,0xfb8e,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0x8800,0xffff,0xffff,0xfb40,0xc000,0xc000,0x8800,0xf80d,0xffff,0xfec0,0xfb40,0xc000,0x8800,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xfb8e,0xffff,0xffff,0xffff,0xf800,0xf80d,0xfb8e,0xf800,0xf800,0xf800,0xf800,0xf800,0xf800,0x8800,0xc000,0xc000,0xc000,0xc000,0xc000,0x8800,0xf80d,0x8800,0xc000,0xc000,0xc000,0x8800,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d};
Image bonusMalusBall = Image(bonusMalusBallData);

// Ball + (20)
const uint16_t bonusBallData[] = {7,5,3, 5,  0xf80d, 0, 0xf80d,0xffff,0xffff,0xfb40,0xb7e0,0x2580,0xf80d,0xb7e0,0xffff,0xfec0,0xffff,0x2580,0x2580,0x2580,0x3260,0xfb40,0xffff,0xffff,0xffff,0x5380,0x3260,0xf80d,0x3260,0x5380,0xffff,0x5380,0x3260,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xb7e0,0xdfef,0xdfef,0xb7e0,0x2580,0xf80d,0xb7e0,0x2580,0x2580,0x2580,0x2580,0x2580,0x2580,0x5380,0xffff,0xffff,0xfb40,0x5380,0x5380,0x5380,0xf80d,0xffff,0xfec0,0xffff,0x5380,0x3260,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xb7e0,0xffff,0xffff,0xffff,0x2580,0xf80d,0xb7e0,0x2580,0x2580,0xffff,0x2580,0x2580,0x2580,0x3260,0x5380,0x5380,0x5380,0x5380,0x5380,0x3260,0xf80d,0x3260,0x5380,0x5380,0x5380,0x3260,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d};
Image bonusBall = Image(bonusBallData);

// Metal ball (21)
const uint16_t bonusSteelBallData[] = {7,5,3, 5, 0xf80d, 0, 0xf80d,0x23e0,0x4208,0xffff,0x4208,0x23e0,0xf80d,0x23e0,0x2220,0x8410,0x8410,0x8410,0x2220,0x23e0,0x2220,0x2220,0x3186,0x8410,0x3186,0x2220,0x2220,0xf80d,0x2220,0x1960,0x1960,0x1960,0x2220,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0x23e0,0x8760,0xffff,0x8760,0x23e0,0xf80d,0x23e0,0x2220,0x23e0,0x23e0,0x23e0,0x2220,0x23e0,0x2220,0x2220,0x3186,0x8410,0x3186,0x2220,0x2220,0xf80d,0x2220,0x8410,0x8410,0x8410,0x2220,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0x23e0,0x8410,0xa514,0x8410,0x23e0,0xf80d,0x23e0,0x2220,0x23e0,0x23e0,0x23e0,0x2220,0x23e0,0x2220,0x2220,0x2220,0x2220,0x2220,0x2220,0x2220,0xf80d,0x2220,0x1960,0x1960,0x1960,0x2220,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d,0xf80d};
Image bonusSteelBall = Image(bonusSteelBallData);


void Bonus::bonusMove(float dt) {
    for (int8_t i = 0; i < game.bonusNb; i++)  {
        SerialUSB.print("   i: ");
        SerialUSB.print(i);
        SerialUSB.print("   y: ");
        SerialUSB.println(bonus[i].y);
        bonus[i].y +=  _bonusSpeed * dt;
        this ->_bonusCheckCollision(i);
    } 
}     


void Bonus::_bonusCheckCollision(uint8_t i) {
// Test if bonus touch the Paddle
    if (((bonus[i].x + this ->sizeX) >= paddle.x) && (bonus[i].x <= paddle.x + paddle.sizeX) && ((bonus[i].y  + this ->sizeY) >= paddle.y) && (bonus[i].y <= paddle.y + paddle.sizeY)) {
        switch (bonus[i].bType) {
            case 11 :  // Bonus life
                game.lives++;
                this ->_bonusClear(i);;
                if (game.sound)gb.sound.fx(SBonus);
            break;

            case 12 :  // Paddle size ++
                if (paddle.sizeX < paddle.paddleWidthMax) paddle.sizeX = paddle.sizeX + 2; 
                this ->_bonusClear(i);;
                if (game.sound)gb.sound.fx(SBonus);
            break;

            case 13 :  // Paddle size --
                if (paddle.sizeX > paddle.paddleWidthMin) paddle.sizeX = paddle.sizeX - 2; 
                this ->_bonusClear(i);;
                if (game.sound)gb.sound.fx(SLostlife);
            break;

            case 14 :  // Glue
                paddle.glue = true; 
                this ->_bonusClear(i);;
                paddle.nbGlue = NB_DEF_GLUE;
                if (game.sound)gb.sound.fx(SLostlife);
            break;

            case 17 :  // Paddle mini
                paddle.sizeX = paddle.paddleWidthMin;
                this ->_bonusClear(i);;
                if (game.sound)gb.sound.fx(SLostlife);
            break;

            case 18 : // Malus life
                game.lives--;
                this ->_bonusClear(i);;
                if (game.sound)gb.sound.fx(SLostlife);
            break;

            case 19 :  // Ball size ++
                if (ball.radius < ball.ballSizeMaxi) ball.radius++; 
                ball.metal = false;
                this ->_bonusClear(i);;
                if (game.sound)gb.sound.fx(SBonus);
            break;

            case 20 :  // Ball size --
                if (ball.radius > ball.ballSizeMini) ball.radius = ball.radius - 1; 
                ball.metal = false;
                this ->_bonusClear(i);;
                if (game.sound)gb.sound.fx(SLostlife);
            break;

            case 21 :  // Ball metal
                ball.radius = 2; 
                ball.metal = true;
                this ->_bonusClear(i);;
                if (game.sound)gb.sound.fx(SBonus);
            break;        
            
        } // end Switch
    } // enf If
    if (bonus[i].y > 64) this ->_bonusClear(i);;
 } // end Test_collision_Bonus



void Bonus::bonusDraw() {
    for (int8_t i = 0; i < game.bonusNb; i++)  {

        switch (bonus[i].bType) {
            case 11 :  // Bonus life
            // gb.display.drawImage(bonus[i].x / _bonusMultiplier, bonus[i].y/_bonusMultiplier, bonusVie);
            gb.display.drawImage(bonus[i].x, bonus[i].y, bonusVie);
            break;

            case 12 :  // Bonus Paddle+
            gb.display.drawImage(bonus[i].x, bonus[i].y, bonusPaddlePlus);
            break;

            case 13 :  // Malus Paddle -
            gb.display.drawImage(bonus[i].x, bonus[i].y, bonusPaddleMalus);
            break;

            case 14 :  // Bonus Glue
            gb.display.drawImage(bonus[i].x, bonus[i].y, bonusGlue);
            break;

            case 17 :  // Bonus Mini Paddle
            gb.display.drawImage(bonus[i].x, bonus[i].y, bonusMalusPaddleRed);
            break;
            
            case 18 : // Malus life
            gb.display.drawImage(bonus[i].x, bonus[i].y, bonusMalusLife);
            break;

            case 19 : // Malus Ball -
            gb.display.drawImage(bonus[i].x, bonus[i].y, bonusMalusBall);
            break;
            
            case 20 : // Bonus Ball +
            gb.display.drawImage(bonus[i].x, bonus[i].y, bonusBall);
            break;

            case 21 : // Bonus Metal ball
            gb.display.drawImage(bonus[i].x, bonus[i].y, bonusSteelBall);
            break;
            
      } // end Switch
      delay(2);
    }  
} // end Draw_Bonus


 void Bonus::_bonusClear(uint8_t i){
    for (int8_t temp = 0; temp < game.bonusNb; temp++)  {
        bonus[temp].x =  bonus[temp+1].x;
        bonus[temp].y =  bonus[temp+1].y;
        bonus[temp].bType = bonus[temp+1].bType;
    } 
    game.bonusNb--;
 } 


 void Bonus::bonusAdd(uint8_t bType,uint8_t bx,uint8_t by){
  bonus[game.bonusNb].x = bx;  // *_bonusMultiplier;
  bonus[game.bonusNb].y = by;  // *_bonusMultiplier;
  bonus[game.bonusNb].bType = bType;
  game.bonusNb++;
}
